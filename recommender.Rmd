```{r}
library(recommenderlab)
library(dplyr)
library(ggplot2)
library(ggridges)
library(tidyr)
library(coop)
library(gridExtra)
library(naniar)
```
Aufgabe: Reduziere den MovieLense Datensatz auf rund 400 Kunden 
und 700 Filme, indem du Filme und Kunden  mit sehr wenigen Ratings 
entfernst.
Untersuche und dokumentiere die Eigenschaften des reduzierten 
Datensatzes und beschreibe den Effekt der Datenreduktion:
  1.Anzahl Filme und Kunden sowie Sparsity vor und nach Datenreduktion
  
```{r}
dim(MovieLense_user_movies_reduced_df)[1]
```

```{r}
data(MovieLense)
MovieLense_df <- as(MovieLense, "data.frame")
MovieLenseMeta_df <- as(MovieLenseMeta, "data.frame")
```
```{r}
MOVIE_MIN_RATED = 700
MIN_MOVIES_RATED = 400
####

user_min_movies_rated <- MovieLense_df %>%
  count(user) %>%
  arrange(desc(n)) %>%
  head(MIN_MOVIES_RATED) %>%
  select(user)

## Calculate 
movies_min_rated <- MovieLense_df %>%
  count(item) %>%
  arrange(desc(n)) %>%
  head(MOVIE_MIN_RATED) %>%
  select(item)

random_movie_names <- sample(x = unique(MovieLense_df$item), size = MOVIE_MIN_RATED)
Movies_random_selected_df <- MovieLense_df %>%
  dplyr::filter(item %in% random_movie_names)

#Movies_random_selected_df <- slice(MovieLense_df, sample(1:n())) %>%
#  head(dim(MovieLense_user_movies_reduced_df)[1])

MovieLense_user_movies_reduced_df <- MovieLense_df %>%
  inner_join(user_min_movies_rated, by='user') %>%
  inner_join(movies_min_rated, by='item')

### Sparsity
image(MovieLense)
image(coerce(MovieLense_user_movies_reduced_df, MovieLense))
image(coerce(Movies_random_selected_df, MovieLense))
```
```{r}
calc_sparsity <- function(RRM){
  density_ = nratings(RRM) / (nrow(RRM)*ncol(RRM))
  return (1 - density_)
}
full_spars = calc_sparsity(coerce(MovieLense_df, MovieLense))
reduced_spars = calc_sparsity(coerce(MovieLense_user_movies_reduced_df, MovieLense))
rand_spars = calc_sparsity(coerce(Movies_random_selected_df, MovieLense))

all_spars = c(full_spars, reduced_spars, rand_spars)
spars_name = c('Full Matrix', 'Reduced Matrix', 'Random Matrix')

ggplot(mapping=aes(spars_name, all_spars)) + 
  geom_col() +
  ggtitle(paste("Sparsity der verschiedenen Matrizen")) +
  xlab("") + ylab("Sparse / Non-Sparse")
```
```{r}
all_spars
```
```{r}
rating_mean <- MovieLense_user_movies_reduced_df %>%
  group_by(item) %>%
  summarise(mean = mean(rating)) %>%
  select(item, mean) %>%
  arrange(desc(mean))

p1 <- ggplot(rating_mean, aes(x=mean)) + 
  geom_density() +
  ggtitle("Verteilung der mittleren Kundenratings nach Reduktion") + 
  geom_vline(aes(xintercept=mean(mean)),
            color="blue", linetype="dashed", size=1) +
  xlim(1, 5)



rating_mean <- coerce(MovieLense, data.frame()) %>%
  group_by(item) %>%
  summarise(mean = mean(rating)) %>%
  select(item, mean) %>%
  arrange(desc(mean))

p2 <-ggplot(rating_mean, aes(x=mean)) + 
  geom_density() +
  ggtitle("Verteilung der mittleren Kundenratings vor Reduktion") + 
  geom_vline(aes(xintercept=mean(mean)),
            color="blue", linetype="dashed", size=1)

rating_mean <- Movies_random_selected_df %>%
  group_by(item) %>%
  summarise(mean = mean(rating)) %>%
  select(item, mean) %>%
  arrange(desc(mean))


p3 <-ggplot(rating_mean, aes(x=mean)) + 
  geom_density() +
  ggtitle("Verteilung der mittleren Kundenratings bei Zufallsauswahl") + 
  geom_vline(aes(xintercept=mean(mean)),
            color="blue", linetype="dashed", size=1)

grid.arrange(p1, p2, p3, ncol=1, nrow=3)

```
Aufgabe: Erzeuge einen IBCF Recommender und analysiere die 
Ähnlichkeitsmatrix des trainierten Modelles für den reduzierten 
Datensatz.
1.Zerlege den reduzierten MovieLense Datensatz in ein disjunktes Trainings-
und Testdatenset im Verhältnis 4:1
```{r}
train_test_split <- function(RRM, ratio=0.8){
  train_idx <- sample(x = c(TRUE, FALSE), size = nrow(RRM), replace = TRUE, prob = c(ratio, 1 - ratio))
  
  RRM_train <- RRM[train_idx, ]
  RRM_test <- RRM[!train_idx, ]
  
  return (c(RRM_train, RRM_test))
}

set.seed(4)

train_test_reduced <- train_test_split(coerce(MovieLense_user_movies_reduced_df, MovieLense))
train_test_random <- train_test_split(coerce(Movies_random_selected_df, MovieLense))
```
```{r}
Movies_random_selected_df
```

2.Trainiere ein IBCF Modell mit 30 Nachbarn und Cosine Similarity
```{r}
Recommender_model_IBCF_reduced <- Recommender(data = train_test_reduced[[1]], method = "IBCF", parameter = list(k = 30, 
    method = "Cosine"))
Recommender_model_IBCF_random <- Recommender(data = train_test_random[[1]], method = "IBCF", parameter = list(k = 30, 
    method = "Cosine"))
Recommender_model_IBCF_reduced
Recommender_model_IBCF_random
```
3. Bestimme die Verteilung der Filme, welche bei IBCF für paarweise 
Ähnlichkeitsvergleiche verwendet werden,
```{r}
similarity_mat <- as.matrix(Recommender_model_IBCF_reduced@model$sim)
similarity_lower <- similarity_mat[lower.tri(similarity_mat)]
similarity_lower = data.frame(similarity_lower)
similarity_lower[similarity_lower < 0.0000001] <- NA
similarity_lower[similarity_lower > 0.9999999] <- NA 
similarity_lower <- similarity_lower %>% drop_na()
similarity_lower
```
  similarity_lower[similarity_lower > 0.999999] <- NA  
  similarity_lower[similarity_lower == 0] <- NA  

```{r}
plot_similarity_matrix <- function(Rec_Model, title, ignore_zeros=TRUE){
  similarity_mat <- as.matrix(Rec_Model@model$sim)
  similarity_lower <- similarity_mat[lower.tri(similarity_mat)]
  similarity_lower = data.frame(similarity_lower)
  similarity_lower[similarity_lower < 0.0000001] <- NA
  similarity_lower[similarity_lower > 0.9999999] <- NA
  similarity_lower <- similarity_lower %>% drop_na()
  similarity_lower <- coerce(similarity_lower, similarity_mat)
  
  p <- ggplot(mapping = aes(x=similarity_lower)) +
    geom_histogram(fill="grey", na.rm=TRUE) + labs(title=title) + xlab("Cosine-Aehnlichkeit")
  return (p)
}
p1 <- plot_similarity_matrix(Recommender_model_IBCF_reduced, 'Verteilung Aehnlichkeiten reduzierter Datensatz')
p2 <- plot_similarity_matrix(Recommender_model_IBCF_random, 'Verteilung Aehnlichkeiten random Datensatz')
p1
p2

```
4.Bestimme die Filme, die am häufigsten in der Cosine-Ähnlichkeitsmatrix 
auftauchen und analysiere deren Vorkommen und Ratings im reduzierten 
Datensatz.
```{r}



```
Aufgabe: Vergleiche und diskutiere Top-N Empfehlungen von IBCF und 
UBCF Modellen mit 30 Nachbarn und Cosine Similarity für den 
reduzierten Datensatz.
1.Berechne Top-15 Empfehlungen für Testkunden mit IBCF und UBCF
```{r}
NUM_RECOMMENDATIONS = 15
####

Recommender_model_UBCF <- Recommender(data = MovieLense_train, method = "UBCF", parameter = list(method = "Cosine"))


Pred_IBCF <- predict(object = Recommender_model_IBCF, newdata = MovieLense_test, n = NUM_RECOMMENDATIONS)
Pred_UBCF <- predict(object = Recommender_model_UBCF, newdata = MovieLense_test, n = NUM_RECOMMENDATIONS)

###

```
```{r}
Pred_UBCF_df <- data.frame(user = sort(rep(1:length(Pred_UBCF@items), Pred_UBCF@n)), 
    rating = unlist(Pred_UBCF@ratings), index = unlist(Pred_UBCF@items))

Pred_IBCF_df <- data.frame(user = sort(rep(1:length(Pred_IBCF@items), Pred_IBCF@n)), 
                           rating = unlist(Pred_IBCF@ratings), index = unlist(Pred_IBCF@items))


Pred_IBCF_df$title <- Pred_IBCF@itemLabels[Pred_IBCF_df$index]
Pred_IBCF_df$year <- MovieLenseMeta$year[Pred_IBCF_df$index]
Pred_IBCF_df

Pred_UBCF_df$title <- Pred_UBCF@itemLabels[Pred_UBCF_df$index]
Pred_UBCF_df$year <- MovieLenseMeta$year[Pred_UBCF_df$index]
Pred_UBCF_df

```
```{r}
MovieLenseMeta_df

```
```{r}



```